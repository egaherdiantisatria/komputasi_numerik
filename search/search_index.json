{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apa sih Nilai Error ituu ?? Secara umum terdapat dua sumber utama penyebab terjadinya error dalam perhitungan numerik, yaitu: Error pembulatan ( round-off error ) Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Keterbatasan komputer dalam menyajikan bilangan riil menghasilkan error yang disebut error pembulatan. Sebagai contoh 1/6 = 0.166666666\u2026 tidak dapat dinyatakan secara tepat oleh komputer karena digit 6 panjangnya tidak terbatas. Komputer hanya mampu merepresentasikan sejumlah digit (atau bit dalam sistem biner) saja. Bilangan riil yang panjangnya melebihi jumlah digit (bit) yang dapat direpresentasikan oleh komputer dibulatkan ke bilangan terdekat. Misalnya sebuah komputer hanya dapat merepresentasikan bilangan riil dalam 6 digit angka berarti, maka representasi bilangan 1/6 = 0.1666666666\u2026 di dalam komputer 6-digit tersebut adalah 0.166667. Galat pembulatannya adalah 1/6 \u2013 0.166667 = -0.000000333. Contoh dalam sistem biner misalnya 1/10 = 0.000110011001100110011 00110011\u20262 direpresentasikan di dalam komputer dalam jumlah bit yang terbatas. Kebanyakan komputer digital mempunyai dua buah cara penyajian bilangan riil, yaitu bilangan titik-tetap (fixed point) dan bilangan titik-kambang (floatingpoint). Dalam format bilangan titik -tetap setiap bilangan disajikan dengan jumlah tempat desimal yang tetap, misalnya 62.358, 0.013, 1.000. Sedangkan dalam format bilangan titik-kambang setiap bilangan disajikan dengan jumlah digit berarti yang sudah tetap, misalnya 0.6238 103 0.1714 ^10-13 atau ditulis juga 0.6238E+03 0.1714E-13. Digit-digit berarti di dalam format bilangan titik-kambang disebut juga angka bena (significant figure). Galat Pemotongan ( truncation error ) Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak. Contoh Kasus : Diketahui: y = x2 + 5x + 6 x=3 h=0.3 h=0.2 h=0.1 Ditanya : Et, Ea, \u03b5t, \u03b5a ? Jawab : Saat h=0,3 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,3 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,3 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,027 Saat h = 0,2 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,2 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) (Et = Va \u2013 Va sebelum) Jadi Ea yang didapat adalah -0,2 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,02 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5a yang didapatkan adalah -0,00892 jika di persenkan menjadi -0.0089% Saat h = 0,1 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,1 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) Jadi Ea yang didapat adalah -0,1 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,01 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5t yang didapatkan adalah -0,0901 jika di persenkan menjadi -0.0901% import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Home"},{"location":"#apa-sih-nilai-error-ituu","text":"Secara umum terdapat dua sumber utama penyebab terjadinya error dalam perhitungan numerik, yaitu: Error pembulatan ( round-off error ) Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Keterbatasan komputer dalam menyajikan bilangan riil menghasilkan error yang disebut error pembulatan. Sebagai contoh 1/6 = 0.166666666\u2026 tidak dapat dinyatakan secara tepat oleh komputer karena digit 6 panjangnya tidak terbatas. Komputer hanya mampu merepresentasikan sejumlah digit (atau bit dalam sistem biner) saja. Bilangan riil yang panjangnya melebihi jumlah digit (bit) yang dapat direpresentasikan oleh komputer dibulatkan ke bilangan terdekat. Misalnya sebuah komputer hanya dapat merepresentasikan bilangan riil dalam 6 digit angka berarti, maka representasi bilangan 1/6 = 0.1666666666\u2026 di dalam komputer 6-digit tersebut adalah 0.166667. Galat pembulatannya adalah 1/6 \u2013 0.166667 = -0.000000333. Contoh dalam sistem biner misalnya 1/10 = 0.000110011001100110011 00110011\u20262 direpresentasikan di dalam komputer dalam jumlah bit yang terbatas. Kebanyakan komputer digital mempunyai dua buah cara penyajian bilangan riil, yaitu bilangan titik-tetap (fixed point) dan bilangan titik-kambang (floatingpoint). Dalam format bilangan titik -tetap setiap bilangan disajikan dengan jumlah tempat desimal yang tetap, misalnya 62.358, 0.013, 1.000. Sedangkan dalam format bilangan titik-kambang setiap bilangan disajikan dengan jumlah digit berarti yang sudah tetap, misalnya 0.6238 103 0.1714 ^10-13 atau ditulis juga 0.6238E+03 0.1714E-13. Digit-digit berarti di dalam format bilangan titik-kambang disebut juga angka bena (significant figure). Galat Pemotongan ( truncation error ) Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak.","title":"Apa sih Nilai Error ituu ??"},{"location":"#contoh-kasus","text":"Diketahui: y = x2 + 5x + 6 x=3 h=0.3 h=0.2 h=0.1 Ditanya : Et, Ea, \u03b5t, \u03b5a ? Jawab : Saat h=0,3 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,3 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,3 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,027 Saat h = 0,2 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,2 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) (Et = Va \u2013 Va sebelum) Jadi Ea yang didapat adalah -0,2 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,02 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5a yang didapatkan adalah -0,00892 jika di persenkan menjadi -0.0089% Saat h = 0,1 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,1 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) Jadi Ea yang didapat adalah -0,1 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,01 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5t yang didapatkan adalah -0,0901 jika di persenkan menjadi -0.0901% import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Contoh Kasus :"},{"location":"Metode%20Romberg/","text":"Metode Romberg \u00b6 Integrasi Romberg ialah teknik yang digunakan untuk menganalisis kasus fungsi yang diintegrasikan telah tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan secara efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson, yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat, misal: O(h2N)O(h2N) --> O(h2N+2)O(h2N+2) Misal I(h) dan I(2h) dihitung dengan metode Trapesium dengan orde galat O(h2)O(h2), maka ekstrapolasi Richardson menghasilkan metode Simpson \u2153 dengan orde galat O(h4)O(h4). Kemudian jika I(h) dan I(2h)* dihitung dengan metode Simpson \u2153, maka akan menghasilkan kaidah Boole denganrorde galat O(h6)O(h6). Persamaan ekstrapolasi Richardson : J=I(h)+I(h)\u2212I(2h)2q\u22121J=I(h)+I(h)\u2212I(2h)2q\u22121 Misalkan I adalah nilai integrasi yang dinyatakan sebagai I=Ak+Ch2+Dh4+Eh6+...I=Ak+Ch2+Dh4+Eh6+... dalam hal ini h=(b\u2212a)nh=(b\u2212a)n dan AkAk merupakan nilai integrasi dengan metode Trapesium dengan jumlah pias n=2kn=2k dan Orde galatnya adalah O(h2)O(h2). A0,A1,...AkA0,A1,...Ak digunakan dalam persamaan ekstrapolasi Richardson untuk mendapatkan B1,B2,...,BkB1,B2,...,Bk, yaitu Bk=Ak+Ak\u2212Ak\u2212122\u22121Bk=Ak+Ak\u2212Ak\u2212122\u22121 Jadi, nilai I setelah diupdate adalah I=Bk+D\u2032h4+E\u2032h6+\u2026I=Bk+D\u2032h4+E\u2032h6+\u2026 dengan orde galat BkBk adalah O(h4)O(h4). Selanjutnya, menggunakan B1,B2,..,BkB1,B2,..,Bk pada persamaan ekstrapolasi Richardson untuk mendapatkan runtunan C2,C3,...,CkC2,C3,...,Ck, yaitu Ck=Bk+Bk\u2212Bk\u2212124\u22121Ck=Bk+Bk\u2212Bk\u2212124\u22121 nilai I saat ini adalah I=Ck+E\"h6+...I=Ck+E\"h6+... dengan orde galat CkCk adalah O(h6)O(h6). Demikian seterusnya. Dari runtunan diatas diperoleh tabel Romberg berikut: O ( h 2) Metode Trapesium O ( h 4) Metode Simpson O ( h 6) Metode Boole O ( h 8) Perbaikan ketiga O ( h 10) dst A 0 A 1 B 1 A 2 B 2 C 2 A 3 B 3 C 3 D3 A 4 B 4 C 4 D4 E4 E4 ialah nilai integrasi yang lebih baik. Listing Pemrograman \u00b6 Contoh 1 : Dalam contoh ini kita dapat melihat bahwa dengan menggunakan metode scipy.integrate.romberg() , kita bisa mendapatkan integrasi romberg dari fungsi yang dapat dipanggil dari batas a ke b dengan menggunakan metode scipy.integrate.romberg() . # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x: np.exp( - x * * 2 ) # using scipy.integrate.romberg() geek = integrate.romberg(gfg, 0 , 3 , show = True ) print (geek) Output: Romberg integrasi <function vectorize1..vfunc di 0x00000209C3641EA0> dari [0, 3] Langkah StepSize Hasil 1 3.000000 1.500185 2 1.500000 0,908191 0,710860 4 0.750000 0.886180 0.878843 0.890042 8 0.375000 0.886199 0.886206 0.886696 0.886643 16 0.187500 0.886205 0.886207 0.886207 0.886200 0.886198 32 0,093750 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 64 0.046875 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 128 0.023438 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 Hasil akhir adalah 0,8862073482595311 setelah 129 evaluasi fungsi. Contoh 2: # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x: np.exp( - x * * 2 ) + 1 / np.sqrt(np.pi) # using scipy.integrate.romberg() geek = integrate.romberg(gfg, 1 , 2 , show = True ) print (geek) Output: Integrasi Romberg dari <function vectorize1..vfunc at 0x00000209E1605400> dari [1, 2] Langkah StepSize Hasil 1 1,000000 0,757287 2 0,500000 0,713438 0,698822 4 0.250000 0.702909 0.699400 0.699438 8 0.125000 0.700310 0.699444 0.699447 0.699447 16 0,062500 0,699663 0,699447 0,699447 0,699447 0,699447 32 0.031250 0.699501 0.699447 0.699447 0.699447 0.699447 0.699447 Hasil akhir adalah 0,6994468414978009 setelah 33 evaluasi fungsi.","title":"Metode Romberg[\u00b6](https://lukmanarimashuri.github.io/metode_romberg/#metode-romberg)"},{"location":"Metode%20Romberg/#metode-romberg","text":"Integrasi Romberg ialah teknik yang digunakan untuk menganalisis kasus fungsi yang diintegrasikan telah tersedia. Teknik ini memiliki keunggulan untuk menghasilkan nilai-nilai dari fungsi yang digunakan secara efisien bagi pengintegrasian secara numerik. Integrasi Romberg didasarkan pada ekstrapolasi Richardson, yaitu metode untuk mengkombinasikan dua perkiraan integral secara numerik untuk memperoleh nilai ketiga, yang lebih akurat, misal: O(h2N)O(h2N) --> O(h2N+2)O(h2N+2) Misal I(h) dan I(2h) dihitung dengan metode Trapesium dengan orde galat O(h2)O(h2), maka ekstrapolasi Richardson menghasilkan metode Simpson \u2153 dengan orde galat O(h4)O(h4). Kemudian jika I(h) dan I(2h)* dihitung dengan metode Simpson \u2153, maka akan menghasilkan kaidah Boole denganrorde galat O(h6)O(h6). Persamaan ekstrapolasi Richardson : J=I(h)+I(h)\u2212I(2h)2q\u22121J=I(h)+I(h)\u2212I(2h)2q\u22121 Misalkan I adalah nilai integrasi yang dinyatakan sebagai I=Ak+Ch2+Dh4+Eh6+...I=Ak+Ch2+Dh4+Eh6+... dalam hal ini h=(b\u2212a)nh=(b\u2212a)n dan AkAk merupakan nilai integrasi dengan metode Trapesium dengan jumlah pias n=2kn=2k dan Orde galatnya adalah O(h2)O(h2). A0,A1,...AkA0,A1,...Ak digunakan dalam persamaan ekstrapolasi Richardson untuk mendapatkan B1,B2,...,BkB1,B2,...,Bk, yaitu Bk=Ak+Ak\u2212Ak\u2212122\u22121Bk=Ak+Ak\u2212Ak\u2212122\u22121 Jadi, nilai I setelah diupdate adalah I=Bk+D\u2032h4+E\u2032h6+\u2026I=Bk+D\u2032h4+E\u2032h6+\u2026 dengan orde galat BkBk adalah O(h4)O(h4). Selanjutnya, menggunakan B1,B2,..,BkB1,B2,..,Bk pada persamaan ekstrapolasi Richardson untuk mendapatkan runtunan C2,C3,...,CkC2,C3,...,Ck, yaitu Ck=Bk+Bk\u2212Bk\u2212124\u22121Ck=Bk+Bk\u2212Bk\u2212124\u22121 nilai I saat ini adalah I=Ck+E\"h6+...I=Ck+E\"h6+... dengan orde galat CkCk adalah O(h6)O(h6). Demikian seterusnya. Dari runtunan diatas diperoleh tabel Romberg berikut: O ( h 2) Metode Trapesium O ( h 4) Metode Simpson O ( h 6) Metode Boole O ( h 8) Perbaikan ketiga O ( h 10) dst A 0 A 1 B 1 A 2 B 2 C 2 A 3 B 3 C 3 D3 A 4 B 4 C 4 D4 E4 E4 ialah nilai integrasi yang lebih baik.","title":"Metode Romberg\u00b6"},{"location":"Metode%20Romberg/#listing-pemrograman","text":"Contoh 1 : Dalam contoh ini kita dapat melihat bahwa dengan menggunakan metode scipy.integrate.romberg() , kita bisa mendapatkan integrasi romberg dari fungsi yang dapat dipanggil dari batas a ke b dengan menggunakan metode scipy.integrate.romberg() . # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x: np.exp( - x * * 2 ) # using scipy.integrate.romberg() geek = integrate.romberg(gfg, 0 , 3 , show = True ) print (geek) Output: Romberg integrasi <function vectorize1..vfunc di 0x00000209C3641EA0> dari [0, 3] Langkah StepSize Hasil 1 3.000000 1.500185 2 1.500000 0,908191 0,710860 4 0.750000 0.886180 0.878843 0.890042 8 0.375000 0.886199 0.886206 0.886696 0.886643 16 0.187500 0.886205 0.886207 0.886207 0.886200 0.886198 32 0,093750 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 64 0.046875 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 128 0.023438 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 0.886207 Hasil akhir adalah 0,8862073482595311 setelah 129 evaluasi fungsi. Contoh 2: # import numpy and scipy.integrate import numpy as np from integrate import scipy gfg = lambda x: np.exp( - x * * 2 ) + 1 / np.sqrt(np.pi) # using scipy.integrate.romberg() geek = integrate.romberg(gfg, 1 , 2 , show = True ) print (geek) Output: Integrasi Romberg dari <function vectorize1..vfunc at 0x00000209E1605400> dari [1, 2] Langkah StepSize Hasil 1 1,000000 0,757287 2 0,500000 0,713438 0,698822 4 0.250000 0.702909 0.699400 0.699438 8 0.125000 0.700310 0.699444 0.699447 0.699447 16 0,062500 0,699663 0,699447 0,699447 0,699447 0,699447 32 0.031250 0.699501 0.699447 0.699447 0.699447 0.699447 0.699447 Hasil akhir adalah 0,6994468414978009 setelah 33 evaluasi fungsi.","title":"Listing Pemrograman\u00b6"},{"location":"biodata/","text":"Nama : Ega Herdianti S. NIM : 180411100026 Prodi : Teknik Informatika Mata Kuliah : Komputasi Numerik","title":"Biodata"},{"location":"solusi%20numerik/","text":"Metode Bagi-Dua (Bisection Method) Metode Bagi-Dua adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian, lalu memilih dari dua bagian ini dipilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. Prosedur Metode Bagi-Dua : Misal dijamin bahwa adalah fungsi kontinyu pada interval dan . Ini artinya bahwa paling tidak harus memiliki akar pada interval . Kemudian definisikan titik tengah pada interval yaitu . Dari sini kita memperoleh dua subinterval yaitu dan . Setelah itu, cek apakah atau ? Jika maka (artinya titik digantikan oleh titik yang berfungsi sebagai titik pada iterasi berikutnya), jika tidak maka . Dari iterasi pertama kita memperoleh interval yang baru dan titik tengah yang baru. Kemudian lakukan pengecekan lagi seperti sebelumnya sampai memperoleh error yang cukup kecil. Contoh : Carilah akar dari pada interval . Penyelesaian : Dalam penyelesaian ini saya akan menggunakan sampai iterasi ke-10 dan menggunakan 5 angka dibelakang koma. f(x) = x3 + 4x2 \u2013 10 f(1) = (1)3 + 4(1)2 \u2013 10 = -5 f(2) = (2)3 + 4(2)2 \u2013 10 = 14 f(1.5) = (1.5)3 + 4(1.5)2 \u2013 10 = 2.375 f(1.25) = (1.25)3 + 4(1.25)2 \u2013 10 = -1.79687 f(1.375) = (1.375)3 + 4(1.375)2 \u2013 10 = 0.16210 f(1.3125) = (1.3125)3 + 4(1.3125)2 \u2013 10 = -0.84838 f(1.34375) = (1.34375)3 + 4(1.34375)2 \u2013 10 = -0.35098 f(1.35938) = (1.35938)3 + 4(1.35938)2 \u2013 10 = -0.09632 f(1.36719) = (1.36719)3 + 4(1.36719)2 \u2013 10 = 0.03239 f(1.36329) = (1.36329)3 + 4(1.36329)2 \u2013 10 = -0.03200 f(1.36524) = (1.36524)3 + 4(1.36524)2 \u2013 10 = 0.000016 f(1.36426) = (1.36426)3 + 4(1.36426)2 \u2013 10 = -0.01601 f(1.36329) = (1.36329)3 + 4(1.36329)2 \u2013 10 = -0.00784 12345678910 111.251.251.31251.343751.359381.359381.363291.36329 21.51.51.3751.3751.3751.3751.367191.367191.36524 1.51.251.3751.31251.343751.359381.367191.363291.365241.36426 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 ++++++++++ +\u2013+\u2013\u2013\u2013+\u2013+\u2013 \u2013+\u2013+++\u2013+\u2013+ +\u2013+\u2013\u2013\u2013+\u2013+\u2013 Jadi akar yang diperoleh dari menggunakan 10 iterasi adalah 1.36426 Program Kode # Regula-Falsi def Regfal ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 jika fa * fb < 0 : n + = 1 cetak ( \"iterasi kem\" + str ( n )) x = (( a* abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 jika fa * fx < 0 : b = x lain : a = x jika abs ( a - b ) < e: cetak ( x ) lain : Regfal ( a , b , n ) lain : jika fa < fb : a - = 0,1 lainnya : b + = 0,1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a:\" )) b = float ( input ( \"Masukkan interval b:\" )) Regfal ( a , b , 0 ) `Masukkan interval a: 1` `Masukkan interval b: 2.1` `iterasi ke-1` `iterasi ke-2` `iterasi ke-3` `iterasi ke-4` `iterasi ke-5` `iterasi ke-6` `iterasi ke-7` `iterasi ke-8` `iterasi ke-9` `iterasi ke-10` `iterasi ke-11` `iterasi ke-12` `iterasi ke-13` `iterasi ke-14` `iterasi ke-15` `iterasi ke-16` `iterasi ke-17` `iterasi ke-18` `iterasi ke-19` `iterasi ke-20` `iterasi ke-21` `iterasi ke-22` `iterasi ke-23` `iterasi ke-24` `iterasi ke-25` `iterasi ke-26` `iterasi ke-27` `iterasi ke-28` `iterasi ke-29` `iterasi ke-30` `iterasi ke-31` `iterasi ke-32` `iterasi ke-33` `iterasi ke-34` `iterasi ke-35` `iterasi ke-36` `iterasi ke-37` `iterasi ke-38` `iterasi ke-39` `iterasi ke-40` `iterasi ke-41` `iterasi ke-42` `iterasi ke-43` `iterasi ke-44` `iterasi ke-45` `iterasi ke-46` `iterasi ke-47` `2.0000000000000004 Metode Regula Falsi (Regula Falsi Method) Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant . Menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva / grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . Prosedur Metode Regular Falsi Menentukan interval titik awal x0 dan x1 sedemikian sehingga . Setelah itu menghitung . Kemudian periksa apakah atau , jika maka atau , jika tidak maka atau . Kemudian ulangi terus langkah-langkah tersebut sampai ketemu \u2018akar\u2019 yang paling mendekati \u2018akar yang sebenarnya\u2019 atau mempunyai error yang cukup kecil. Secara umum, rumus untuk Metode Regular Falsi ini adalah sebagai berikut Untuk mendapatkan rumus tersebut, perhatikan gambar diatas. syarat : pandang garis l yang melalui dan sebagai gradien garis, sehingga diperoleh persamaan gradient sebagai berikut karena merupakan titik potong pada sumbu- maka , sehingga diperoleh atau jika ditulis secara umum menjadi Contoh : Tentukan akar dari menggunakan Metode Regular Falsi sampai 9 iterasi. Penyelesaian : 6 iterasi 1 : ambil dan maka ambil dan iterasi 2 : maka ambil dan iterasi 3 : maka ambil dan iterasi 4 : maka ambil dan iterasi 5 : maka ambil dan iterasi 6 : maka ambil dan iterasi 7 : maka ambil dan iterasi 8 : maka ambil dan iterasi 9 : 123456789 -11.81.843191.879191.908291.931201.948881.962291.97234 333333333 1.81.843191.879191.908291.931201.948881.962291.972341.97979 -42-0.672-0.57817-0.47975-0.38595-0.30269-0.23262-0.17597-0.13152 181818181818181818 -0.672-0.57817-0.47975-0.38595-0.30269-0.23262-0.17597-0.13152-0.09741 Jadi akar dari persamaan menggunakan Metode Regular Falsi adalah Program Kode # Regula-Falsi def Regfal ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 jika fa * fb < 0 : n + = 1 cetak ( \"iterasi kem\" + str ( n )) x = (( a* abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 jika fa * fx < 0 : b = x lain : a = x jika abs ( a - b ) < e: cetak ( x ) lain : Regfal ( a , b , n ) lain : jika fa < fb : a - = 0,1 lainnya : b + = 0,1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a:\" )) b = float ( input ( \"Masukkan interval b:\" )) Regfal ( a , b , 0 ) Keluaran Masukkan interval a: 1 Masukkan interval b: 2.1 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 iterasi ke-33 iterasi ke-34 iterasi ke-35 iterasi ke-36 iterasi ke-37 iterasi ke-38 iterasi ke-39 iterasi ke-40 iterasi ke-41 iterasi ke-42 iterasi ke-43 iterasi ke-44 iterasi ke-45 iterasi ke-46 iterasi ke-47 2.0000000000000004 Metode Newton-Raphson (Newton-Raphson Method) Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan sebagai titik awal, kemudian menarik garis lurus (misal garis ) yang menyinggung titik . Hal ini berakibat garis memotong sumbu- di titik . Setelah itu diulangi langkah sebelumnya tapi sekarang dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan dengan yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis adalah perpotongan garis dengan sumbu- dan maka koordinat titik . . . untuk n = 1, 2, 3, \u2026 Contoh : Tentukan akar dari persamaan menggunakan Metode Newton-Raphson. Penyelesaian : iterasi 1 : ambil titik awal x0 = 3 f(3) = 4(3)3 \u2013 15(3)2 + 17(3) \u2013 6 = 18 f\u2019(3) = 12(3)2 \u2013 30(3) + 17 = 35 x1 = 3 \u2013 = 2.48571 iterasi 2 : f(2.48571) = 4(2.48571)3 \u2013 15(2.48571)2 + 17(2.48571) \u2013 6 = 5.01019 f\u2019(2.48571) = 12(2.48571)2 \u2013 30(2.48571) + 17 = 16.57388 x2 = 2.48571 \u2013 = 2.18342 iterasi 3 : f(2.18342) = 4(2.18342)3 \u2013 15(2.18342)2 + 17(2.18342) \u2013 6 = 1.24457 f\u2019(2.18342) = 12(2.18342)2 \u2013 30(2.18342) + 17 = 8.70527 x3 = 2.18342 \u2013 = 2.04045 iterasi 4 : f(2.04045) = 4(2.04045)3 \u2013 15(2.04045)2 + 17(2.04045) \u2013 6 = 0.21726 f\u2019(2.04045) = 12(2.04045)2 \u2013 30(2.04045) + 17 = 5.74778 x4 = 2.04045 \u2013 = 2.00265 iterasi 5 : f(3) = 4(2.00265)3 \u2013 15(2.00265)2 + 17(2.00265) \u2013 6 = 0.01334 f\u2019(2.00265) = 12(2.00265)2 \u2013 30(2.00265) + 17 = 5.04787 x5 = 2.00265 \u2013 = 2.00001 iterasi 6 : f(2.00001) = 4(2.00001)3 \u2013 15(2.00001)2 + 17(2.00001) \u2013 6 = 0.00006 f\u2019(2.00001) = 12(2.00001)2 \u2013 30(2.00001) + 17 = 5.00023 x6 = 2.00001 \u2013 = 2.00000 iterasi 7 : f(2) = 4(2)3 \u2013 15(2)2 + 17(2) \u2013 6 = 0 jika disajikan dalam tabel, maka seperti tabel dibawah ini. 0123456 32.485712.183422.040452.002652.000012.00000 185.010191.244570.217260.013340.000060.00000 3516.573888.705275.747785.047875.000235.00000 karena pada iterasi ketujuh maka akar dari persamaan tersebut adalah . Program # Newton-Raphson x = float ( input ( \"Masukkan nilai awal x:\" )) n = 0 e = 0,001 sedangkan n > = 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 faks = 2 * x - 5 x1 = x - ( fx / faks ) jika abs ( x1 - x ) < e atau n > = 100 : print ( \"Jumlah iterasi:\" , n + 1 ) print ( x ) memecah lain : x = x1 n + = 1 Keluaran Masukkan nilai awal x: 2.4 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 iterasi saat X5 Jumlah iterasi: 6 1.9999976821746035 Metode Secant (Secant Method) Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan . Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant . Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . Perhatikan gambar dibawah ini. Persamaan garis l adalah Karena maka , sehingga diperoleh secara umum rumus Metode Secant ini ditulis Prosedur Metode Secant : Ambil dua titik awal, misal dan . Ingat bahwa pengambilan titik awal tidak disyaratkan alias pengambilan secara sebarang. Setelah itu hitung menggunakan rumus diatas. Kemudian pada iterasi selanjutnya ambil dan sebagai titik awal dan hitung . Kemudian ambil dan sebagai titik awal dan hitung . Begitu seterusnya sampai iterasi yang diingankan atau sampai mencapai error yang cukup kecil. Contoh : Tentukan salah satu akar dari menggunakan Metode Secant sampai 9 iterasi. Penyelesaian : iterasi 1 : ambil dan (ngambil titik awal ini sebarang saja, tidak ada syarat apapun) iterasi 2 : ambil dan iterasi 3 : ambil dan iterasi 4 : ambil dan iterasi 5 : ambil dan iterasi 6 : ambil dan iterasi 7 : ambil dan iterasi 8 : ambil dan iterasi 9 : ambil dan 123456789 -131.81.843192.109321.967521.994232.000362.00000 31.81.843192.109321.967521.994232.000362.000002.00000 1.81.843192.109321.967521.994232.000362.000002.000002.00000 -4218-0.672-0.578170.65939-0.15303-0.028540.00178-0.00002 18-0.672-0.578170.65939-0.15303-0.028540.00178-0.000020.00000 -0.672-0.578170.65939-0.15303-0.028540.00178-0.000020.000000.00000 Jadi salah satu akar dari adalah 2 Program #Secant def garis potong ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + * x + 6 n + = 1 print ( \"iterasi ke-\" + str ( n )) jika abs ( a - b ) 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 < e : print ( \"Jumlah iterasi:\" , n ) cetak ( x ) lain-lain : a = b b = x Garis potong ( a , b , n ) a = float ( input( \"Masukkan nilai a:\" )) b = float ( input ( \"Masukkan nilai b:\" )) n = 0 Garis potong ( a , b , 0 ) Keluaran Masukkan nilai a: 1 Masukkan nilai b: 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi: 6 1.9999999975499005","title":"Metode Bagi-Dua (Bisection Method)"},{"location":"solusi%20numerik/#metode-bagi-dua-bisection-method","text":"Metode Bagi-Dua adalah algoritma pencarian akar pada sebuah interval. Interval tersebut membagi dua bagian, lalu memilih dari dua bagian ini dipilih bagian mana yang mengandung akar dan bagian yang tidak mengandung akar dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh akar persamaan atau mendekati akar persamaan. Metode ini berlaku ketika ingin memecahkan persamaan dengan merupakan fungsi kontinyu. Prosedur Metode Bagi-Dua : Misal dijamin bahwa adalah fungsi kontinyu pada interval dan . Ini artinya bahwa paling tidak harus memiliki akar pada interval . Kemudian definisikan titik tengah pada interval yaitu . Dari sini kita memperoleh dua subinterval yaitu dan . Setelah itu, cek apakah atau ? Jika maka (artinya titik digantikan oleh titik yang berfungsi sebagai titik pada iterasi berikutnya), jika tidak maka . Dari iterasi pertama kita memperoleh interval yang baru dan titik tengah yang baru. Kemudian lakukan pengecekan lagi seperti sebelumnya sampai memperoleh error yang cukup kecil. Contoh : Carilah akar dari pada interval . Penyelesaian : Dalam penyelesaian ini saya akan menggunakan sampai iterasi ke-10 dan menggunakan 5 angka dibelakang koma. f(x) = x3 + 4x2 \u2013 10 f(1) = (1)3 + 4(1)2 \u2013 10 = -5 f(2) = (2)3 + 4(2)2 \u2013 10 = 14 f(1.5) = (1.5)3 + 4(1.5)2 \u2013 10 = 2.375 f(1.25) = (1.25)3 + 4(1.25)2 \u2013 10 = -1.79687 f(1.375) = (1.375)3 + 4(1.375)2 \u2013 10 = 0.16210 f(1.3125) = (1.3125)3 + 4(1.3125)2 \u2013 10 = -0.84838 f(1.34375) = (1.34375)3 + 4(1.34375)2 \u2013 10 = -0.35098 f(1.35938) = (1.35938)3 + 4(1.35938)2 \u2013 10 = -0.09632 f(1.36719) = (1.36719)3 + 4(1.36719)2 \u2013 10 = 0.03239 f(1.36329) = (1.36329)3 + 4(1.36329)2 \u2013 10 = -0.03200 f(1.36524) = (1.36524)3 + 4(1.36524)2 \u2013 10 = 0.000016 f(1.36426) = (1.36426)3 + 4(1.36426)2 \u2013 10 = -0.01601 f(1.36329) = (1.36329)3 + 4(1.36329)2 \u2013 10 = -0.00784 12345678910 111.251.251.31251.343751.359381.359381.363291.36329 21.51.51.3751.3751.3751.3751.367191.367191.36524 1.51.251.3751.31251.343751.359381.367191.363291.365241.36426 \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013 ++++++++++ +\u2013+\u2013\u2013\u2013+\u2013+\u2013 \u2013+\u2013+++\u2013+\u2013+ +\u2013+\u2013\u2013\u2013+\u2013+\u2013 Jadi akar yang diperoleh dari menggunakan 10 iterasi adalah 1.36426 Program Kode # Regula-Falsi def Regfal ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 jika fa * fb < 0 : n + = 1 cetak ( \"iterasi kem\" + str ( n )) x = (( a* abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 jika fa * fx < 0 : b = x lain : a = x jika abs ( a - b ) < e: cetak ( x ) lain : Regfal ( a , b , n ) lain : jika fa < fb : a - = 0,1 lainnya : b + = 0,1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a:\" )) b = float ( input ( \"Masukkan interval b:\" )) Regfal ( a , b , 0 ) `Masukkan interval a: 1` `Masukkan interval b: 2.1` `iterasi ke-1` `iterasi ke-2` `iterasi ke-3` `iterasi ke-4` `iterasi ke-5` `iterasi ke-6` `iterasi ke-7` `iterasi ke-8` `iterasi ke-9` `iterasi ke-10` `iterasi ke-11` `iterasi ke-12` `iterasi ke-13` `iterasi ke-14` `iterasi ke-15` `iterasi ke-16` `iterasi ke-17` `iterasi ke-18` `iterasi ke-19` `iterasi ke-20` `iterasi ke-21` `iterasi ke-22` `iterasi ke-23` `iterasi ke-24` `iterasi ke-25` `iterasi ke-26` `iterasi ke-27` `iterasi ke-28` `iterasi ke-29` `iterasi ke-30` `iterasi ke-31` `iterasi ke-32` `iterasi ke-33` `iterasi ke-34` `iterasi ke-35` `iterasi ke-36` `iterasi ke-37` `iterasi ke-38` `iterasi ke-39` `iterasi ke-40` `iterasi ke-41` `iterasi ke-42` `iterasi ke-43` `iterasi ke-44` `iterasi ke-45` `iterasi ke-46` `iterasi ke-47` `2.0000000000000004","title":"Metode Bagi-Dua (Bisection Method)"},{"location":"solusi%20numerik/#metode-regula-falsi-regula-falsi-method","text":"Metode Regular Falsi adalah panduan konsep Metode Bagi-Dua dan Metode Secant . Menggunakan konsep Metode Bagi-Dua karena dimulai dengan pemilihan dua titik awal dan sedemikian sehingga dan berlawanan tanda atau . Kemudian menggunakan konsep Metode Secant yaitu dengan menarik garis dari titik dan sedemikian sehingga garis berpotongan pada sumbu \u2013 dan memotong kurva / grafik fungsi pada titik dan . Sehingga Metode Regular Falsi ini akan menghasilkan titik potong pada sumbu- yaitu yang merupakan calon akar dan tetap berada dalam interval . Metode ini kemudian berlanjut dengan menghasilkan berturut-turut interval yang semuanya berisi akar . Prosedur Metode Regular Falsi Menentukan interval titik awal x0 dan x1 sedemikian sehingga . Setelah itu menghitung . Kemudian periksa apakah atau , jika maka atau , jika tidak maka atau . Kemudian ulangi terus langkah-langkah tersebut sampai ketemu \u2018akar\u2019 yang paling mendekati \u2018akar yang sebenarnya\u2019 atau mempunyai error yang cukup kecil. Secara umum, rumus untuk Metode Regular Falsi ini adalah sebagai berikut Untuk mendapatkan rumus tersebut, perhatikan gambar diatas. syarat : pandang garis l yang melalui dan sebagai gradien garis, sehingga diperoleh persamaan gradient sebagai berikut karena merupakan titik potong pada sumbu- maka , sehingga diperoleh atau jika ditulis secara umum menjadi Contoh : Tentukan akar dari menggunakan Metode Regular Falsi sampai 9 iterasi. Penyelesaian : 6 iterasi 1 : ambil dan maka ambil dan iterasi 2 : maka ambil dan iterasi 3 : maka ambil dan iterasi 4 : maka ambil dan iterasi 5 : maka ambil dan iterasi 6 : maka ambil dan iterasi 7 : maka ambil dan iterasi 8 : maka ambil dan iterasi 9 : 123456789 -11.81.843191.879191.908291.931201.948881.962291.97234 333333333 1.81.843191.879191.908291.931201.948881.962291.972341.97979 -42-0.672-0.57817-0.47975-0.38595-0.30269-0.23262-0.17597-0.13152 181818181818181818 -0.672-0.57817-0.47975-0.38595-0.30269-0.23262-0.17597-0.13152-0.09741 Jadi akar dari persamaan menggunakan Metode Regular Falsi adalah Program Kode # Regula-Falsi def Regfal ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 jika fa * fb < 0 : n + = 1 cetak ( \"iterasi kem\" + str ( n )) x = (( a* abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 jika fa * fx < 0 : b = x lain : a = x jika abs ( a - b ) < e: cetak ( x ) lain : Regfal ( a , b , n ) lain : jika fa < fb : a - = 0,1 lainnya : b + = 0,1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a:\" )) b = float ( input ( \"Masukkan interval b:\" )) Regfal ( a , b , 0 ) Keluaran Masukkan interval a: 1 Masukkan interval b: 2.1 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 iterasi ke-7 iterasi ke-8 iterasi ke-9 iterasi ke-10 iterasi ke-11 iterasi ke-12 iterasi ke-13 iterasi ke-14 iterasi ke-15 iterasi ke-16 iterasi ke-17 iterasi ke-18 iterasi ke-19 iterasi ke-20 iterasi ke-21 iterasi ke-22 iterasi ke-23 iterasi ke-24 iterasi ke-25 iterasi ke-26 iterasi ke-27 iterasi ke-28 iterasi ke-29 iterasi ke-30 iterasi ke-31 iterasi ke-32 iterasi ke-33 iterasi ke-34 iterasi ke-35 iterasi ke-36 iterasi ke-37 iterasi ke-38 iterasi ke-39 iterasi ke-40 iterasi ke-41 iterasi ke-42 iterasi ke-43 iterasi ke-44 iterasi ke-45 iterasi ke-46 iterasi ke-47 2.0000000000000004","title":"Metode Regula Falsi (Regula Falsi Method)"},{"location":"solusi%20numerik/#metode-newton-raphson-newton-raphson-method","text":"Metode Newton-Raphson adalah metode pencarian akar suatu fungsi dengan pendekatan satu titik, dimana fungsi mempunyai turunan. Metode ini dianggap lebih mudah dari Metode Bagi-Dua (Bisection Method) karena metode ini menggunakan pendekatan satu titik sebagai titik awal. Semakin dekat titik awal yang kita pilih dengan akar sebenarnya, maka semakin cepat konvergen ke akarnya. Prosedur Metode Newton : menentukan sebagai titik awal, kemudian menarik garis lurus (misal garis ) yang menyinggung titik . Hal ini berakibat garis memotong sumbu- di titik . Setelah itu diulangi langkah sebelumnya tapi sekarang dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan dengan yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. Perhatikan gambar diatas untuk menurunkan rumus Metode Newton-Raphson persamaan garis adalah perpotongan garis dengan sumbu- dan maka koordinat titik . . . untuk n = 1, 2, 3, \u2026 Contoh : Tentukan akar dari persamaan menggunakan Metode Newton-Raphson. Penyelesaian : iterasi 1 : ambil titik awal x0 = 3 f(3) = 4(3)3 \u2013 15(3)2 + 17(3) \u2013 6 = 18 f\u2019(3) = 12(3)2 \u2013 30(3) + 17 = 35 x1 = 3 \u2013 = 2.48571 iterasi 2 : f(2.48571) = 4(2.48571)3 \u2013 15(2.48571)2 + 17(2.48571) \u2013 6 = 5.01019 f\u2019(2.48571) = 12(2.48571)2 \u2013 30(2.48571) + 17 = 16.57388 x2 = 2.48571 \u2013 = 2.18342 iterasi 3 : f(2.18342) = 4(2.18342)3 \u2013 15(2.18342)2 + 17(2.18342) \u2013 6 = 1.24457 f\u2019(2.18342) = 12(2.18342)2 \u2013 30(2.18342) + 17 = 8.70527 x3 = 2.18342 \u2013 = 2.04045 iterasi 4 : f(2.04045) = 4(2.04045)3 \u2013 15(2.04045)2 + 17(2.04045) \u2013 6 = 0.21726 f\u2019(2.04045) = 12(2.04045)2 \u2013 30(2.04045) + 17 = 5.74778 x4 = 2.04045 \u2013 = 2.00265 iterasi 5 : f(3) = 4(2.00265)3 \u2013 15(2.00265)2 + 17(2.00265) \u2013 6 = 0.01334 f\u2019(2.00265) = 12(2.00265)2 \u2013 30(2.00265) + 17 = 5.04787 x5 = 2.00265 \u2013 = 2.00001 iterasi 6 : f(2.00001) = 4(2.00001)3 \u2013 15(2.00001)2 + 17(2.00001) \u2013 6 = 0.00006 f\u2019(2.00001) = 12(2.00001)2 \u2013 30(2.00001) + 17 = 5.00023 x6 = 2.00001 \u2013 = 2.00000 iterasi 7 : f(2) = 4(2)3 \u2013 15(2)2 + 17(2) \u2013 6 = 0 jika disajikan dalam tabel, maka seperti tabel dibawah ini. 0123456 32.485712.183422.040452.002652.000012.00000 185.010191.244570.217260.013340.000060.00000 3516.573888.705275.747785.047875.000235.00000 karena pada iterasi ketujuh maka akar dari persamaan tersebut adalah . Program # Newton-Raphson x = float ( input ( \"Masukkan nilai awal x:\" )) n = 0 e = 0,001 sedangkan n > = 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 faks = 2 * x - 5 x1 = x - ( fx / faks ) jika abs ( x1 - x ) < e atau n > = 100 : print ( \"Jumlah iterasi:\" , n + 1 ) print ( x ) memecah lain : x = x1 n + = 1 Keluaran Masukkan nilai awal x: 2.4 iterasi saat X0 iterasi saat X1 iterasi saat X2 iterasi saat X3 iterasi saat X4 iterasi saat X5 Jumlah iterasi: 6 1.9999976821746035","title":"Metode Newton-Raphson (Newton-Raphson Method)"},{"location":"solusi%20numerik/#metode-secant-secant-method","text":"Pada Metode Newton-Raphson memerlukan syarat wajib yaitu fungsi harus memiliki turunan . Sehingga syarat wajib ini dianggap sulit karena tidak semua fungsi bisa dengan mudah mencari turunannya. Oleh karena itu muncul ide dari yaitu mencari persamaan yang ekivalen dengan rumus turunan fungsi. Ide ini lebih dikenal dengan nama Metode Secant . Ide dari metode ini yaitu menggunakan gradien garis yang melalui titik dan . Perhatikan gambar dibawah ini. Persamaan garis l adalah Karena maka , sehingga diperoleh secara umum rumus Metode Secant ini ditulis Prosedur Metode Secant : Ambil dua titik awal, misal dan . Ingat bahwa pengambilan titik awal tidak disyaratkan alias pengambilan secara sebarang. Setelah itu hitung menggunakan rumus diatas. Kemudian pada iterasi selanjutnya ambil dan sebagai titik awal dan hitung . Kemudian ambil dan sebagai titik awal dan hitung . Begitu seterusnya sampai iterasi yang diingankan atau sampai mencapai error yang cukup kecil. Contoh : Tentukan salah satu akar dari menggunakan Metode Secant sampai 9 iterasi. Penyelesaian : iterasi 1 : ambil dan (ngambil titik awal ini sebarang saja, tidak ada syarat apapun) iterasi 2 : ambil dan iterasi 3 : ambil dan iterasi 4 : ambil dan iterasi 5 : ambil dan iterasi 6 : ambil dan iterasi 7 : ambil dan iterasi 8 : ambil dan iterasi 9 : ambil dan 123456789 -131.81.843192.109321.967521.994232.000362.00000 31.81.843192.109321.967521.994232.000362.000002.00000 1.81.843192.109321.967521.994232.000362.000002.000002.00000 -4218-0.672-0.578170.65939-0.15303-0.028540.00178-0.00002 18-0.672-0.578170.65939-0.15303-0.028540.00178-0.000020.00000 -0.672-0.578170.65939-0.15303-0.028540.00178-0.000020.000000.00000 Jadi salah satu akar dari adalah 2 Program #Secant def garis potong ( a , b , n ): e = 0,001 fa = a ** 2 - 5 * a + * x + 6 n + = 1 print ( \"iterasi ke-\" + str ( n )) jika abs ( a - b ) 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 < e : print ( \"Jumlah iterasi:\" , n ) cetak ( x ) lain-lain : a = b b = x Garis potong ( a , b , n ) a = float ( input( \"Masukkan nilai a:\" )) b = float ( input ( \"Masukkan nilai b:\" )) n = 0 Garis potong ( a , b , 0 ) Keluaran Masukkan nilai a: 1 Masukkan nilai b: 1.5 iterasi ke-1 iterasi ke-2 iterasi ke-3 iterasi ke-4 iterasi ke-5 iterasi ke-6 Jumlah iterasi: 6 1.9999999975499005","title":"Metode Secant (Secant Method)"},{"location":"tugas/","text":"# metode numerik f1 <- function(x,y){y/(2*x+1)} num <- euler(f1, x0=0, y0=1, h=0.05, n=100) # metode analitik f2 <- function(x){sqrt(2*x+1)} x0 <- 0 y0 <- 1 x <- x0 y <- y0 for(i in 1:100){ y0 <- f2(x0+0.05) x0 <- x0+0.05 x <- c(x, x0) y <- c(y, y0) } true <- data.frame(x=x, y=y) Gambar 10.1: Visualisasi integrasi numerik dengan metode Euler dan metode analitik Berdasarkan hasil visualisasi dapat dilihat bahwa metode Euler dapat dengan baik memberikan pendekatan nilai integrasi persamaan. Pembaca dapat mencoba untuk melakukan simulasi kembali dengan nilai hh yang lebih kecil.","title":"Tugas"}]}