{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Apa sih Nilai Error ituu ?? Secara umum terdapat dua sumber utama penyebab terjadinya error dalam perhitungan numerik, yaitu: Error pembulatan ( round-off error ) Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Keterbatasan komputer dalam menyajikan bilangan riil menghasilkan error yang disebut error pembulatan. Sebagai contoh 1/6 = 0.166666666\u2026 tidak dapat dinyatakan secara tepat oleh komputer karena digit 6 panjangnya tidak terbatas. Komputer hanya mampu merepresentasikan sejumlah digit (atau bit dalam sistem biner) saja. Bilangan riil yang panjangnya melebihi jumlah digit (bit) yang dapat direpresentasikan oleh komputer dibulatkan ke bilangan terdekat. Misalnya sebuah komputer hanya dapat merepresentasikan bilangan riil dalam 6 digit angka berarti, maka representasi bilangan 1/6 = 0.1666666666\u2026 di dalam komputer 6-digit tersebut adalah 0.166667. Galat pembulatannya adalah 1/6 \u2013 0.166667 = -0.000000333. Contoh dalam sistem biner misalnya 1/10 = 0.000110011001100110011 00110011\u20262 direpresentasikan di dalam komputer dalam jumlah bit yang terbatas. Kebanyakan komputer digital mempunyai dua buah cara penyajian bilangan riil, yaitu bilangan titik-tetap (fixed point) dan bilangan titik-kambang (floatingpoint). Dalam format bilangan titik -tetap setiap bilangan disajikan dengan jumlah tempat desimal yang tetap, misalnya 62.358, 0.013, 1.000. Sedangkan dalam format bilangan titik-kambang setiap bilangan disajikan dengan jumlah digit berarti yang sudah tetap, misalnya 0.6238 103 0.1714 ^10-13 atau ditulis juga 0.6238E+03 0.1714E-13. Digit-digit berarti di dalam format bilangan titik-kambang disebut juga angka bena (significant figure). Galat Pemotongan ( truncation error ) Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak. Contoh Kasus : Diketahui: y = x2 + 5x + 6 x=3 h=0.3 h=0.2 h=0.1 Ditanya : Et, Ea, \u03b5t, \u03b5a ? Jawab : Saat h=0,3 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,3 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,3 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,027 Saat h = 0,2 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,2 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) (Et = Va \u2013 Va sebelum) Jadi Ea yang didapat adalah -0,2 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,02 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5a yang didapatkan adalah -0,00892 jika di persenkan menjadi -0.0089% Saat h = 0,1 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,1 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) Jadi Ea yang didapat adalah -0,1 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,01 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5t yang didapatkan adalah -0,0901 jika di persenkan menjadi -0.0901% import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Home"},{"location":"#apa-sih-nilai-error-ituu","text":"Secara umum terdapat dua sumber utama penyebab terjadinya error dalam perhitungan numerik, yaitu: Error pembulatan ( round-off error ) Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil.Masalah timbul apabila komputasi numerik dikerjakan oleh mesin (dalam hal ini dengan menggunakan komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Keterbatasan komputer dalam menyajikan bilangan riil menghasilkan error yang disebut error pembulatan. Sebagai contoh 1/6 = 0.166666666\u2026 tidak dapat dinyatakan secara tepat oleh komputer karena digit 6 panjangnya tidak terbatas. Komputer hanya mampu merepresentasikan sejumlah digit (atau bit dalam sistem biner) saja. Bilangan riil yang panjangnya melebihi jumlah digit (bit) yang dapat direpresentasikan oleh komputer dibulatkan ke bilangan terdekat. Misalnya sebuah komputer hanya dapat merepresentasikan bilangan riil dalam 6 digit angka berarti, maka representasi bilangan 1/6 = 0.1666666666\u2026 di dalam komputer 6-digit tersebut adalah 0.166667. Galat pembulatannya adalah 1/6 \u2013 0.166667 = -0.000000333. Contoh dalam sistem biner misalnya 1/10 = 0.000110011001100110011 00110011\u20262 direpresentasikan di dalam komputer dalam jumlah bit yang terbatas. Kebanyakan komputer digital mempunyai dua buah cara penyajian bilangan riil, yaitu bilangan titik-tetap (fixed point) dan bilangan titik-kambang (floatingpoint). Dalam format bilangan titik -tetap setiap bilangan disajikan dengan jumlah tempat desimal yang tetap, misalnya 62.358, 0.013, 1.000. Sedangkan dalam format bilangan titik-kambang setiap bilangan disajikan dengan jumlah digit berarti yang sudah tetap, misalnya 0.6238 103 0.1714 ^10-13 atau ditulis juga 0.6238E+03 0.1714E-13. Digit-digit berarti di dalam format bilangan titik-kambang disebut juga angka bena (significant figure). Galat Pemotongan ( truncation error ) Galat pemotongan adalah galat yang ditimbulkan oleh pembatasan jumlah komputasi yang digunakan pada proses metode numerik. Banyak metode dalam metode numerik yang penurunan rumusnya menggunakan proses iterasi yang jumlahnya tak terhingga, sehingga untuk membatasi proses penghitungan, jumlah iterasi dibatasi sampai langkah ke n. Hasil penghitungan sampai langkah ke n akan menjadi hasil hampiran dan nilai penghitungan langkah n keatas akan menjadi galat pemotongan. dalam hal ini galat pemotongan kan menjadi sangat kecil sekali jika nilai n di perbesar. Konsekuensinya tentu saja jumlah proses penghitungannya akan semakin banyak.","title":"Apa sih Nilai Error ituu ??"},{"location":"#contoh-kasus","text":"Diketahui: y = x2 + 5x + 6 x=3 h=0.3 h=0.2 h=0.1 Ditanya : Et, Ea, \u03b5t, \u03b5a ? Jawab : Saat h=0,3 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,3 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,3 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,027 Saat h = 0,2 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,2 \u2013 True Value (Vt) Jadi Vt yang didapatkan adalah 11 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) (Et = Va \u2013 Va sebelum) Jadi Ea yang didapat adalah -0,2 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,02 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5a yang didapatkan adalah -0,00892 jika di persenkan menjadi -0.0089% Saat h = 0,1 \u2013 Approximate Value (Va) Jadi Va yang didapatkan adalah 11,1 \u2013 True Error (Et) Jadi Et yang didapat adalah -0,1 -Approximate Error (Ea) Jadi Ea yang didapat adalah -0,1 \u2013 Relative True Error (\u03b5t ) Jadi \u03b5t yang didapatkan adalah -0,01 \u2013 Relative Approximate Error (\u03b5a) Jadi \u03b5t yang didapatkan adalah -0,0901 jika di persenkan menjadi -0.0901% import math x = 4 check = 1 a = 0 b = 1 while check > 0.001 : f_x = 0 f_y = 0 for i in range(a): f_x += (2**i)*x**i/math.factorial(i) for j in range(b): f_y += (2**j)*x**j/math.factorial(j) check = f_y - f_x a+=1 b+=1 print('iterasi ke-',a,'= ',check) output: iterasi ke- 1 = 1.0 iterasi ke- 2 = 8.0 iterasi ke- 3 = 32.0 iterasi ke- 4 = 85.33333333333333 iterasi ke- 5 = 170.66666666666669 iterasi ke- 6 = 273.0666666666666 iterasi ke- 7 = 364.08888888888896 iterasi ke- 8 = 416.1015873015872 iterasi ke- 9 = 416.1015873015872 iterasi ke- 10 = 369.8680776014112 iterasi ke- 11 = 295.89446208112895 iterasi ke- 12 = 215.195972422639 iterasi ke- 13 = 143.46398161509296 iterasi ke- 14 = 88.28552714774924 iterasi ke- 15 = 50.448872655856576 iterasi ke- 16 = 26.90606541645684 iterasi ke- 17 = 13.45303270822842 iterasi ke- 18 = 6.330838921519444 iterasi ke- 19 = 2.8137061873417224 iterasi ke- 20 = 1.184718394670199 iterasi ke- 21 = 0.47388735786807956 iterasi ke- 22 = 0.18052851728316455 iterasi ke- 23 = 0.06564673355751438 iterasi ke- 24 = 0.022833646454728296 iterasi ke- 25 = 0.0076112154847578495 iterasi ke- 26 = 0.0024355889549951826 iterasi ke- 27 = 0.0007494119863622473","title":"Contoh Kasus :"},{"location":"biodata/","text":"Nama : Ega Herdianti S. NIM : 180411100026 Prodi : Teknik Informatika Mata Kuliah : Komputasi Numerik","title":"Biodata"}]}